name: CI/CD Pipeline

on:
  push:
    branches:
      - rc
      - develop
    tags:
      - "prod-v*"

env:
  DOCKER_REPO: "ghcr.io/sds-manager/sdsmanager-sds-search-demo-app"
  SSH_HOST: ${{ secrets.SSH_HOST }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  SUDO_PWD: ${{ secrets.SUDO_PWD }}

jobs:
  build_and_push:
    runs-on: sds-runners
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      tag_name: ${{ steps.set-env.outputs.tag_name }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true
          buildkitd-flags: --debug
          driver-opts: |
            network=host
            env.GODEBUG=http2client=0

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PASSWORD }}

      - name: Determine Environment
        id: set-env
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/develop" ]]; then
            export environment=staging
          elif [[ "${GITHUB_REF}" == "refs/heads/rc" ]]; then
            export environment=rc
          elif [[ "${GITHUB_REF}" == refs/tags/prod-v* ]]; then
            TAG_NAME=${GITHUB_REF#refs/tags/}
            export environment=prod
            echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT
          else
            export environment=test
          fi

          echo "environment=$environment" >> $GITHUB_OUTPUT

      # ===========================
      # Build & push images (staging / rc)
      # ===========================
      - name: Build and push backend staging/rc
        if: ${{ (steps.set-env.outputs.environment == 'staging' || steps.set-env.outputs.environment == 'rc') && github.event_name == 'push' }}
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: |
            ${{ env.DOCKER_REPO }}:backend.${{ steps.set-env.outputs.environment }}.latest
            ${{ env.DOCKER_REPO }}:backend.${{ steps.set-env.outputs.environment }}.${{ github.sha }}
          context: ./backend
          file: ./backend/Dockerfile
          cache-from: type=registry,ref=${{ env.DOCKER_REPO }}:backend.${{ steps.set-env.outputs.environment }}.latest-buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REPO }}:backend.${{ steps.set-env.outputs.environment }}.latest-buildcache,mode=max

      - name: Build and push frontend staging/rc
        if: ${{ (steps.set-env.outputs.environment == 'staging' || steps.set-env.outputs.environment == 'rc') && github.event_name == 'push' }}
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: |
            ${{ env.DOCKER_REPO }}:frontend.${{ steps.set-env.outputs.environment }}.latest
            ${{ env.DOCKER_REPO }}:frontend.${{ steps.set-env.outputs.environment }}.${{ github.sha }}
          context: ./frontend
          file: ./frontend/Dockerfile
          cache-from: type=registry,ref=${{ env.DOCKER_REPO }}:frontend.${{ steps.set-env.outputs.environment }}.latest-buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REPO }}:frontend.${{ steps.set-env.outputs.environment }}.latest-buildcache,mode=max

      # (Optional) prod build & push logic â€“ add if you want prod images too
      # - name: Build and push backend/frontend prod
      #   if: ${{ steps.set-env.outputs.environment == 'prod' && github.event_name == 'push' }}
      #   run: |
      #     docker build -t $DOCKER_REPO:backend.prod.latest -f ./backend/Dockerfile ./backend
      #     docker build -t $DOCKER_REPO:frontend.prod.latest -f ./frontend/Dockerfile ./frontend
      #     docker push $DOCKER_REPO:backend.prod.latest
      #     docker push $DOCKER_REPO:frontend.prod.latest
      #     docker tag $DOCKER_REPO:backend.prod.latest $DOCKER_REPO:backend.prod.${{ github.sha }}
      #     docker tag $DOCKER_REPO:frontend.prod.latest $DOCKER_REPO:frontend.prod.${{ github.sha }}
      #     docker push $DOCKER_REPO:backend.prod.${{ github.sha }}
      #     docker push $DOCKER_REPO:frontend.prod.${{ github.sha }}

      # ===========================
      # Remote secrets / migrations
      # ===========================
      - name: Update secrets and run migrations
        if: ${{ github.event_name != 'pull_request' && steps.set-env.outputs.environment == 'staging' }}
        uses: appleboy/ssh-action@v1.2.1
        with:
          host: ${{ env.SSH_HOST }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_KEY }}
          envs: SUDO_PWD
          script: |
            echo "Releasing to ${{ steps.set-env.outputs.environment }}..."
            echo "$SUDO_PWD" | sudo -S sh /sds/toolkit/sds/k8s/sds_staging/sds_demo/sds_demo.sh develop $SUDO_PWD

      # ===========================
      # Update SDS Kit repo deploy.yaml
      # ===========================
      - name: Update SDS Kit repository
        if: ${{ steps.set-env.outputs.environment != 'test' }}
        uses: actions/github-script@v7
        env:
          ENVIRONMENT: ${{ steps.set-env.outputs.environment }}
          SHA: ${{ github.sha }}
          SDS_REPO: ${{ env.DOCKER_REPO }}
        with:
          github-token: ${{ secrets.GHCR_PASSWORD }}
          script: |
            const owner = "sds-manager";
            const repo = "sds-kit";
            const ownerRepo = `${owner}/${repo}`;
            const branch = "main";
            const sds_service = "sds_demo";
            const path = `sds/k8s/sds_${process.env.ENVIRONMENT}/${sds_service}/deploy.yaml`;

            core.info(`Starting update for ${sds_service} in ${process.env.ENVIRONMENT} environment`);
            core.info(`Target repository: ${ownerRepo}`);
            core.info(`Target file: ${path}`);

            // 1) Read current file
            core.info(`Reading current deployment file from ${branch} branch...`);
            const res = await github.request("GET /repos/{owner}/{repo}/contents/{path}", {
              owner, repo, path, ref: branch,
              headers: { accept: "application/vnd.github.raw+json" }
            });
            core.info("âœ“ Successfully retrieved deployment file");

            const content = Buffer.from(
              res.data.content
                ? Buffer.from(res.data.content, "base64").toString("utf8")
                : res.data,
              "utf8"
            ).toString();

            const baseTag = `${process.env.ENVIRONMENT}.${process.env.SHA}`;
            const backendTag = `backend.${baseTag}`;
            const frontendTag = `frontend.${baseTag}`;

            // Patterns:
            // image: ghcr.io/...:backend.oldTag
            // image: "ghcr.io/...:frontend.oldTag"
            // Keep repo, replace only the part after `backend.` / `frontend.`
            const backendPattern = /(^\s*image:\s*"?[^":]+:backend\.)[^"\s']+/gm;
            const frontendPattern = /(^\s*image:\s*"?[^":]+:frontend\.)[^"\s']+/gm;

            core.info(`Updating backend image tag suffix to: ${backendTag}`);
            core.info(`Updating frontend image tag suffix to: ${frontendTag}`);

            const backendMatch = backendPattern.test(content);
            backendPattern.lastIndex = 0;
            const frontendMatch = frontendPattern.test(content);
            frontendPattern.lastIndex = 0;

            core.info(`Backend pattern matched? ${backendMatch}`);
            core.info(`Frontend pattern matched? ${frontendMatch}`);

            let updated = content.replace(
              backendPattern,
              `$1${baseTag}`
            );
            updated = updated.replace(
              frontendPattern,
              `$1${baseTag}`
            );

            if (updated === content) {
              core.info("âš  No changes detected in deployment file - no backend/frontend image lines matched");
              return;
            }
            core.info("âœ“ Backend and frontend image tags updated in deployment file");

            // 2) Get the current branch HEAD OID
            core.info(`Fetching current HEAD OID for ${branch} branch...`);
            const branchRef = await github.rest.repos.getBranch({
              owner,
              repo,
              branch,
            });
            const expectedHeadOid = branchRef.data.commit.sha;
            core.info(`âœ“ Current HEAD OID: ${expectedHeadOid}`);

            // 3) Create a commit on branch with fileChanges
            core.info("Creating commit with updated deployment file...");
            const mutation = `
            mutation($branch: String!, $message: String!, $path: String!, $content: Base64String!, $expectedHeadOid: GitObjectID!) {
              createCommitOnBranch(input:{
                branch: { repositoryNameWithOwner: "${ownerRepo}", branchName: $branch },
                message: { headline: $message },
                expectedHeadOid: $expectedHeadOid,
                fileChanges: { additions: [{ path: $path, contents: $content }] }
              }) { commit { oid, url } }
            }`;

            const commitMessage = `${sds_service}: update backend/frontend images to ${baseTag}`;
            core.info(`Commit message: "${commitMessage}"`);

            const result = await github.graphql(mutation, {
              branch,
              message: commitMessage,
              path,
              content: Buffer.from(updated, "utf8").toString("base64"),
              expectedHeadOid,
            });

            core.info("âœ“ Successfully committed changes to sds-kit repository");

            if (result?.createCommitOnBranch?.commit) {
              core.info(`Commit OID: ${result.createCommitOnBranch.commit.oid}`);
              core.info(`Commit URL: ${result.createCommitOnBranch.commit.url}`);
            } else {
              core.info("Commit created successfully (response structure unexpected)");
              core.info(`Response: ${JSON.stringify(result, null, 2)}`);
            }

            core.info("ðŸš€ Deployment file update completed successfully!");
